# Java Backend Encryption Setup

This backend uses **AES-CBC + RSA hybrid encryption** to securely receive requests from clients. Follow these steps to set up keys and test encryption.

---

## 1. Generate RSA Key Pair (Server)

Use **OpenSSL** to generate a 2048-bit RSA key pair:

```bash
# Generate private key
openssl genrsa -out keypair.pem 2048

# Extract public key from private key
openssl rsa -in keypair.pem -outform PEM -pubout -out publickey.pem
```

* `keypair.pem` → **Server private key** (used by backend to decrypt AES keys)
* `publickey.pem` → **Server public key** (used by clients to encrypt AES keys)

---

## 2. AES Configuration

AES is used to encrypt the request payload:

* **AES Mode**: CBC
* **Padding**: PKCS5
* **IV (Initialization Vector)**: Must match on server and client. Example:

```java
private static final String IV = "d80/cxLQY5GGHOo4"; // 16 bytes
```

* **AES Key Length**: 16 bytes (128-bit)
* **AES Key Generation**: Can be dynamically generated by client for each request.

---

## 3. Client Setup

Clients need:

1. **Server public key** (`publickey.pem`)
2. **AES IV** (same as server)

**Client Workflow:**

1. Generate a random **AES key** (16 ASCII characters).
2. Encrypt the JSON payload using **AES-CBC + IV**.
3. Encrypt the AES key using **RSA public key**.
4. Send request in JSON format:

```json
{
  "key": "<RSA-encrypted AES key>",
  "data": "<AES-encrypted payload>"
}
```

**Example Client Call** (JavaScript):

```javascript
class EncryptionClient {
    constructor(publicKeyPem, aesIV) {
        this.publicKeyPem = publicKeyPem;
        this.aesIV = aesIV;
    }

    // Generate random ASCII 16-character AES key
    generateAESKey() {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        let key = '';
        for (let i = 0; i < 16; i++) {
            key += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return key;
    }

    // Encrypt arbitrary data using AES-CBC
    encryptAES(data, key) {
        const cipher = forge.cipher.createCipher('AES-CBC', key);
        cipher.start({ iv: this.aesIV });
        cipher.update(forge.util.createBuffer(JSON.stringify(data), 'utf8'));
        cipher.finish();
        return forge.util.encode64(cipher.output.getBytes());
    }

    // Encrypt AES key using RSA
    encryptRSA(data) {
        const publicKey = forge.pki.publicKeyFromPem(this.publicKeyPem);
        const encrypted = publicKey.encrypt(data, 'RSAES-PKCS1-V1_5');
        return forge.util.encode64(encrypted);
    }

    // Main method: takes any JS object as input and returns { key, data }
    encryptPayload(payload) {
        const aesKey = this.generateAESKey();
        const encryptedData = this.encryptAES(payload, aesKey);
        const encryptedKey = this.encryptRSA(aesKey);
        return { key: encryptedKey, data: encryptedData };
    }
}
const client = new EncryptionClient(PUBLIC_KEY_PEM, AES_IV);
const encryptedRequest = client.encryptPayload({ username: 'shivam', password: 'password123' });

fetch('http://localhost:8765/auth/login', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify(encryptedRequest)
});
```

---

## 4. Server Decryption (Java)

The backend uses a filter (`DecryptionFilter`) to:

1. Read `key` and `data` from incoming JSON.
2. Decrypt `key` using **server private RSA key** → AES key.
3. Decrypt `data` using **AES-CBC + IV** → original JSON payload.

---

## 5. Notes

* AES key **must be exactly 16 bytes** for AES-128-CBC.
* IV must be **16 bytes long**.
* RSA encryption uses **PKCS1 v1.5 padding**.

---

This setup ensures **secure transmission** from clients to backend without exposing passwords or sensitive data in plain text.
